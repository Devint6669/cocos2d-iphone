This is a sound engine to play background music tracks. Thanks to "<b><font><a href="http://www.idevgames.com/forum/member.php?u=756"><b><font color="#a00000">AnotherJake</font></b></a>" </font></b>(Jake Peterson) for putting this together and posting it on <a href="http://www.idevgames.com/forum/showthread.php?t=15280">iDevGames</a>. I've seen a couple of other people use this in the discussion group, but figured it deserved its own page since it is a question I see asked a lot.<br>
<br>
<u><b>Below is the Code</b></u><br>
<br>
<i><b>Use it like this:</b></i><br>
<br>
<div style="text-align: left;">
<pre dir="ltr" style="border: 1px inset ; margin: 0px; padding: 6px; overflow: auto; min-width: 400px; max-width: 800px; max-height: 600px; text-align: left;">GBMusicTrack *song = [[GBMusicTrack alloc] initWithPath:[[NSBundle mainBundle] pathForResource:@"BackgroundMusic" ofType:@"mp3"]];<br>[song setRepeat:YES];<br>[song play];</pre>
</div>
<br>
<br>
<b><i>GBMusicTrack.h</i></b><br>
<br>
<pre dir="ltr" style="border: 1px inset ; margin: 0px; padding: 6px; overflow: auto; min-width: 400px; max-width: 800px; max-height: 600px; text-align: left;">//<br>//  GBMusicTrack.h<br>//  GameBase<br>//<br>//  Created by Jake Peterson (AnotherJake) on 7/6/08.<br>//  Copyright 2008 Jake Peterson. All rights reserved.<br>//<br><br>#import &lt;Cocoa/Cocoa.h&gt;<br>#import &lt;AudioToolbox/AudioQueue.h&gt;<br>#import &lt;AudioToolbox/AudioFile.h&gt;<br><br>#define NUM_QUEUE_BUFFERS	3<br><br>@interface GBMusicTrack : NSObject<br>{<br>	AudioFileID						audioFile;<br>	AudioStreamBasicDescription		dataFormat;<br>	AudioQueueRef					queue;<br>	UInt64							packetIndex;<br>	UInt32							numPacketsToRead;<br>	AudioStreamPacketDescription	*packetDescs;<br>	BOOL							repeat;<br>	BOOL							trackClosed;<br>	AudioQueueBufferRef				buffers[NUM_QUEUE_BUFFERS];<br>}<br><br>- (id)initWithPath:(NSString *)path;<br>- (void)setGain:(Float32)gain;<br>- (void)setRepeat:(BOOL)yn;<br>- (void)play;<br>- (void)pause;<br><br>// close is called automatically in GBMusicTrack's dealloc method, but it is recommended<br>// to call close first, so that the associated Audio Queue is released immediately, instead<br>// of having to wait for a possible autorelease, which may cause some conflict<br>- (void)close;<br><br>extern NSString	*GBMusicTrackFinishedPlayingNotification;<br><br>@end</pre>
<br>
<br>
<b><i>GBMusicTrack.m</i></b><br>
<br>
<pre dir="ltr" style="border: 1px inset ; margin: 0px; padding: 6px; overflow: auto; min-width: 400px; max-width: 800px; max-height: 600px; text-align: left;">//<br>//  GBMusicTrack.m<br>//  GameBase<br>//<br>//  Created by Jake Peterson (AnotherJake) on 7/6/08.<br>//  Copyright 2008 Jake Peterson. All rights reserved.<br>//<br><br>#import "GBMusicTrack.h"<br><br>static UInt32 gBufferSizeBytes = 0x10000; // 64k<br><br>NSString *GBMusicTrackFinishedPlayingNotification = @"GBMusicTrackFinishedPlayingNotification";<br><br>@interface GBMusicTrack (InternalMethods)<br><br>static void BufferCallback(void *inUserData, AudioQueueRef inAQ, AudioQueueBufferRef buffer);<br>- (void)callbackForBuffer:(AudioQueueBufferRef)buffer;<br>- (UInt32)readPacketsIntoBuffer:(AudioQueueBufferRef)buffer;<br><br>@end<br><br>@implementation GBMusicTrack<br><br>#pragma mark -<br>#pragma mark GBMusicTrack<br><br>- (void)dealloc<br>{<br>	[self close];<br>	[super dealloc];<br>}<br><br>- (void)close<br>{<br>	// it is preferrable to call close first, before dealloc if there is a problem waiting for<br>	// an autorelease<br>	if (trackClosed)<br>		return;<br>	trackClosed = YES;<br>	AudioQueueStop(queue, YES);<br>	AudioQueueDispose(queue, YES);<br>	AudioFileClose(audioFile);<br>}<br><br>- (id)initWithPath:(NSString *)path<br>{<br>	UInt32		size, maxPacketSize;<br>	char		*cookie;<br>	int			i;<br>	<br>	if(!(self = [super init])) return nil;<br>	if (path == nil) return nil;<br>	<br>	// try to open up the file using the specified path<br>	if (noErr != AudioFileOpenURL((CFURLRef)[NSURL fileURLWithPath:path], 0x01, kAudioFileCAFType, &amp;audioFile))<br>	{<br>		NSLog(@"GBMusicTrack Error - initWithPath: could not open audio file. Path given was: %@", path);<br>		return nil;<br>	}<br>	<br>	// get the data format of the file<br>	size = sizeof(dataFormat);<br>	AudioFileGetProperty(audioFile, kAudioFilePropertyDataFormat, &amp;size, &amp;dataFormat);<br>	<br>	// create a new playback queue using the specified data format and buffer callback<br>	AudioQueueNewOutput(&amp;dataFormat, BufferCallback, self, nil, nil, 0, &amp;queue);<br>	<br>	// calculate number of packets to read and allocate space for packet descriptions if needed<br>	if (dataFormat.mBytesPerPacket == 0 || dataFormat.mFramesPerPacket == 0)<br>	{<br>		// since we didn't get sizes to work with, then this must be VBR data (Variable BitRate), so<br>		// we'll have to ask Core Audio to give us a conservative estimate of the largest packet we are<br>		// likely to read with kAudioFilePropertyPacketSizeUpperBound<br>		size = sizeof(maxPacketSize);<br>		AudioFileGetProperty(audioFile, kAudioFilePropertyPacketSizeUpperBound, &amp;size, &amp;maxPacketSize);<br>		if (maxPacketSize &gt; gBufferSizeBytes)<br>		{<br>			// hmm... well, we don't want to go over our buffer size, so we'll have to limit it I guess<br>			maxPacketSize = gBufferSizeBytes;<br>			NSLog(@"GBMusicTrack Warning - initWithPath: had to limit packet size requested for file path: %@", path);<br>		}<br>		numPacketsToRead = gBufferSizeBytes / maxPacketSize;<br>		<br>		// will need a packet description for each packet since this is VBR data, so allocate space accordingly<br>		packetDescs = malloc(sizeof(AudioStreamPacketDescription) * numPacketsToRead);<br>	}<br>	else<br>	{<br>		// for CBR data (Constant BitRate), we can simply fill each buffer with as many packets as will fit<br>		numPacketsToRead = gBufferSizeBytes / dataFormat.mBytesPerPacket;<br>		<br>		// don't need packet descriptsions for CBR data<br>		packetDescs = nil;<br>	}<br>	<br>	// see if file uses a magic cookie (a magic cookie is meta data which some formats use)<br>	AudioFileGetPropertyInfo(audioFile, kAudioFilePropertyMagicCookieData, &amp;size, nil);<br>	if (size &gt; 0)<br>	{<br>		// copy the cookie data from the file into the audio queue<br>		cookie = malloc(sizeof(char) * size);<br>		AudioFileGetProperty(audioFile, kAudioFilePropertyMagicCookieData, &amp;size, cookie);<br>		AudioQueueSetProperty(queue, kAudioQueueProperty_MagicCookie, cookie, size);<br>		free(cookie);<br>	}<br>	<br>	// allocate and prime buffers with some data<br>	packetIndex = 0;<br>	for (i = 0; i &lt; NUM_QUEUE_BUFFERS; i++)<br>	{<br>		AudioQueueAllocateBuffer(queue, gBufferSizeBytes, &amp;buffers[i]);<br>		if ([self readPacketsIntoBuffer:buffers[i]] == 0)<br>		{<br>			// this might happen if the file was so short that it needed less buffers than we planned on using<br>			break;<br>		}<br>	}<br>	repeat = NO;<br>	trackClosed = NO;<br>	return self;<br>}<br><br>- (void)setGain:(Float32)gain<br>{<br>	AudioQueueSetParameter(queue, kAudioQueueParam_Volume, gain);<br>}<br><br>- (void)setRepeat:(BOOL)yn<br>{<br>	repeat = yn;<br>}<br><br>- (void)play<br>{<br>	AudioQueueStart(queue, nil);<br>}<br><br>- (void)pause<br>{<br>	AudioQueuePause(queue);<br>}<br><br>#pragma mark -<br>#pragma mark Callback<br><br>static void BufferCallback(void *inUserData, AudioQueueRef inAQ, AudioQueueBufferRef buffer)<br>{<br>	// redirect back to the class to handle it there instead, so we have direct access to the instance variables<br>	[(GBMusicTrack *)inUserData callbackForBuffer:buffer];<br>}<br><br>- (void)callbackForBuffer:(AudioQueueBufferRef)buffer<br>{<br>	if ([self readPacketsIntoBuffer:buffer] == 0)<br>	{<br>		// End Of File reached, so rewind and refill the buffer using the beginning of the file instead<br>		packetIndex = 0;<br>		[self readPacketsIntoBuffer:buffer];<br>		<br>		// if not repeating then we'll pause it so it's ready to play again immediately if needed<br>		if (!repeat)<br>		{<br>			AudioQueuePause(queue);<br>			<br>			// we're not in the main thread during this callback, so enqueue a message on the main thread to post notification<br>			// that we're done, or else the notification will have to be handled in this thread, making things more difficult<br>			[self performSelectorOnMainThread:@selector(postTrackFinishedPlayingNotification:) withObject:nil waitUntilDone:NO];<br>		}<br>	}<br>}<br><br>- (void)postTrackFinishedPlayingNotification:(id)object<br>{<br>	// if we're here then we're in the main thread as specified by the callback, so now we can post notification that<br>	// the track is done without the notification observer(s) having to worry about thread safety and autorelease pools<br>	[[NSNotificationCenter defaultCenter] postNotificationName:GBMusicTrackFinishedPlayingNotification object:self];<br>}<br><br>- (UInt32)readPacketsIntoBuffer:(AudioQueueBufferRef)buffer<br>{<br>	UInt32		numBytes, numPackets;<br>	<br>	// read packets into buffer from file<br>	numPackets = numPacketsToRead;<br>	AudioFileReadPackets(audioFile, NO, &amp;numBytes, packetDescs, packetIndex, &amp;numPackets, buffer-&gt;mAudioData);<br>	if (numPackets &gt; 0)<br>	{<br>		// - End Of File has not been reached yet since we read some packets, so enqueue the buffer we just read into<br>		// the audio queue, to be played next<br>		// - (packetDescs ? numPackets : 0) means that if there are packet descriptions (which are used only for Variable<br>		// BitRate data (VBR)) we'll have to send one for each packet, otherwise zero<br>		buffer-&gt;mAudioDataByteSize = numBytes;<br>		AudioQueueEnqueueBuffer(queue, buffer, (packetDescs ? numPackets : 0), packetDescs);<br>		<br>		// move ahead to be ready for next time we need to read from the file<br>		packetIndex += numPackets;<br>	}<br>	return numPackets;<br>}<br><br>@end</pre>
<br>
<br>
<br>
<wbr>

